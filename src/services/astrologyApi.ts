import axios from 'axios';
import type { AxiosInstance } from 'axios';
import type {
  DailyHoroscope,
  BirthChart,
  BirthData,
  CompatibilityData,
  Panchang,
  ApiResponse
} from '../types/astrology';
import { geminiApi } from './geminiApi';

// Free astrology APIs - using a combination of free APIs
const API_BASE_URL = 'https://api.vedicastroapi.com/v3';
const ASTROLOGY_API_KEY = import.meta.env.VITE_ASTROLOGY_API_KEY || '';

class AstrologyAPI {
  private api: AxiosInstance;
  private useGeminiAsFallback: boolean;

  constructor() {
    this.api = axios.create({
      baseURL: API_BASE_URL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${ASTROLOGY_API_KEY}`
      }
    });
    this.useGeminiAsFallback = true;

    // Request interceptor
    this.api.interceptors.request.use(
      (config) => {
        console.log(`Making API request: ${config.method?.toUpperCase()} ${config.url}`);
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );

    // Response interceptor
    this.api.interceptors.response.use(
      (response) => response,
      (error) => {
        console.error('API Error:', error.response?.data || error.message);
        return Promise.reject(error);
      }
    );
  }

  private async handleApiCall<T>(
    apiCall: Promise<any>,
    geminiFallback?: () => Promise<T>,
    endpoint?: string
  ): Promise<ApiResponse<T>> {
    try {
      const response = await apiCall;
      return {
        data: response.data,
        success: true
      };
    } catch (error: any) {
      console.error('API call failed:', error);

      // Try Gemini as fallback if available
      if (this.useGeminiAsFallback && geminiFallback) {
        try {
          console.log('Attempting Gemini fallback...');
          const geminiData = await geminiFallback();
          return {
            data: geminiData,
            success: true,
            message: 'Data generated by Gemini AI'
          };
        } catch (geminiError: any) {
          console.error('Gemini fallback failed:', geminiError);
        }
      }

      // For demo purposes, return mock data when both APIs fail
      return {
        data: this.getMockData(endpoint || 'unknown') as T,
        success: false,
        message: 'Using demo data - API unavailable'
      };
    }
  }

  private getMockData(endpoint: string): any {
    switch (endpoint) {
      case 'daily-horoscope':
        return this.getMockDailyHoroscope();
      case 'birth-chart':
        return this.getMockBirthChart();
      case 'compatibility':
        return this.getMockCompatibility();
      case 'panchang':
        return this.getMockPanchang();
      default:
        return null;
    }
  }

  private getMockDailyHoroscope(): DailyHoroscope {
    const signs = ['aries', 'taurus', 'gemini', 'cancer', 'leo', 'virgo', 'libra', 'scorpio', 'sagittarius', 'capricorn', 'aquarius', 'pisces'];
    const randomSign = signs[Math.floor(Math.random() * signs.length)];

    return {
      sign: randomSign,
      date: new Date().toISOString().split('T')[0],
      overall: Math.floor(Math.random() * 5) + 1,
      love: Math.floor(Math.random() * 5) + 1,
      career: Math.floor(Math.random() * 5) + 1,
      health: Math.floor(Math.random() * 5) + 1,
      finances: Math.floor(Math.random() * 5) + 1,
      mood: ['Positive', 'Energetic', 'Calm', 'Focused', 'Creative'][Math.floor(Math.random() * 5)],
      advice: "Today brings opportunities for growth and self-reflection. Trust your intuition and embrace positive changes coming your way.",
      luckyNumber: Math.floor(Math.random() * 31) + 1,
      luckyColor: ['Red', 'Blue', 'Green', 'Purple', 'Gold', 'Silver'][Math.floor(Math.random() * 6)]
    };
  }

  private getMockBirthChart(): BirthChart {
    const signs = ['aries', 'taurus', 'gemini', 'cancer', 'leo', 'virgo', 'libra', 'scorpio', 'sagittarius', 'capricorn', 'aquarius', 'pisces'];

    return {
      id: 'mock-chart-' + Date.now(),
      birthData: {
        name: 'John Doe',
        date: '1990-01-01',
        time: '12:00',
        location: 'New York, USA'
      },
      sunSign: signs[Math.floor(Math.random() * signs.length)],
      moonSign: signs[Math.floor(Math.random() * signs.length)],
      risingSign: signs[Math.floor(Math.random() * signs.length)],
      planets: [
        { name: 'Sun', sign: signs[Math.floor(Math.random() * signs.length)], degree: Math.floor(Math.random() * 30), element: 'fire' },
        { name: 'Moon', sign: signs[Math.floor(Math.random() * signs.length)], degree: Math.floor(Math.random() * 30), element: 'water' },
        { name: 'Mercury', sign: signs[Math.floor(Math.random() * signs.length)], degree: Math.floor(Math.random() * 30), element: 'air' },
        { name: 'Venus', sign: signs[Math.floor(Math.random() * signs.length)], degree: Math.floor(Math.random() * 30), element: 'earth' },
        { name: 'Mars', sign: signs[Math.floor(Math.random() * signs.length)], degree: Math.floor(Math.random() * 30), element: 'fire' }
      ],
      houses: Array.from({ length: 12 }, (_, i) => ({
        number: i + 1,
        sign: signs[Math.floor(Math.random() * signs.length)],
        cusp: Math.floor(Math.random() * 30)
      })),
      aspects: [
        {
          planet1: 'Sun',
          planet2: 'Moon',
          type: 'trine',
          angle: 120,
          orb: 3
        }
      ]
    };
  }

  private getMockCompatibility(): CompatibilityData {
    return {
      personA: {
        name: 'Person A',
        date: '1990-01-01',
        time: '12:00',
        location: 'New York, USA'
      },
      personB: {
        name: 'Person B',
        date: '1992-06-15',
        time: '15:30',
        location: 'Los Angeles, USA'
      },
      overall: Math.floor(Math.random() * 40) + 60,
      love: Math.floor(Math.random() * 40) + 60,
      communication: Math.floor(Math.random() * 40) + 60,
      trust: Math.floor(Math.random() * 40) + 60,
      values: Math.floor(Math.random() * 40) + 60,
      description: "This relationship has strong potential for growth and mutual understanding. Communication is key to maintaining harmony.",
      advice: [
        "Practice active listening",
        "Respect each other's independence",
        "Find common interests to explore together",
        "Be patient with differences"
      ],
      challenges: [
        "Different communication styles",
        "Varying emotional needs",
        "Conflict resolution approaches"
      ]
    };
  }

  private getMockPanchang(): Panchang {
    return {
      date: new Date().toISOString().split('T')[0],
      sunrise: '06:30',
      sunset: '18:45',
      moonPhase: 'Waxing Gibbous',
      nakshatra: 'Rohini',
      tithi: 'Panchami',
      yoga: 'Siddha',
      karana: 'Balava',
      auspiciousPeriods: [
        { start: '06:00', end: '08:00', type: 'Abhijit Muhurat' },
        { start: '12:00', end: '14:00', type: 'Rahu Kalam' },
        { start: '17:00', end: '18:00', type: 'Gulikai Kalam' }
      ]
    };
  }

  async getDailyHoroscope(sign: string, date?: string): Promise<ApiResponse<DailyHoroscope>> {
    const targetDate = date || new Date().toISOString().split('T')[0];

    return this.handleApiCall<DailyHoroscope>(
      this.api.get('/horoscope/daily', {
        params: {
          sign,
          date: targetDate,
          lang: 'en'
        }
      }),
      () => geminiApi.generateDailyHoroscope(sign, targetDate),
      'daily-horoscope'
    );
  }

  async getBirthChart(birthData: BirthData): Promise<ApiResponse<BirthChart>> {
    return this.handleApiCall<BirthChart>(
      this.api.post('/astrology/birth-chart', birthData),
      () => geminiApi.generateBirthChart(birthData),
      'birth-chart'
    );
  }

  async getCompatibility(personA: BirthData, personB: BirthData): Promise<ApiResponse<CompatibilityData>> {
    return this.handleApiCall<CompatibilityData>(
      this.api.post('/astrology/compatibility', { personA, personB }),
      () => geminiApi.generateCompatibility(personA, personB),
      'compatibility'
    );
  }

  async getPanchang(date: string, location: string): Promise<ApiResponse<Panchang>> {
    return this.handleApiCall<Panchang>(
      this.api.get('/panchang', {
        params: { date, location }
      }),
      () => geminiApi.generatePanchang(date, location),
      'panchang'
    );
  }

  // Utility method to retry failed API calls
  async retryRequest<T>(requestFn: () => Promise<T>, maxRetries = 3): Promise<T> {
    let lastError: any;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await requestFn();
      } catch (error: any) {
        lastError = error;
        if (attempt < maxRetries) {
          console.log(`Retrying... Attempt ${attempt + 1}/${maxRetries}`);
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Exponential backoff
        }
      }
    }

    throw lastError;
  }
}

export const astrologyApi = new AstrologyAPI();
export default astrologyApi;