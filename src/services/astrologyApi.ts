import type {
  DailyHoroscope,
  BirthChart,
  BirthData,
  CompatibilityData,
  Panchang,
  ApiResponse
} from '../types/astrology';
import { geminiApi } from './geminiApi';

class AstrologyAPI {
  constructor() {
    console.log('AstrologyAPI initialized with Gemini as primary provider');
  }

  private async handleGeminiCall<T>(
    geminiCall: () => Promise<T>,
    endpoint?: string
  ): Promise<ApiResponse<T>> {
    try {
      const geminiData = await geminiCall();
      return {
        data: geminiData,
        success: true,
        message: 'Data generated by Gemini AI'
      };
    } catch (error: any) {
      console.error('Gemini API call failed:', error);

      // Return mock data as fallback
      return {
        data: this.getMockData(endpoint || 'unknown') as T,
        success: false,
        message: 'Using demo data - Gemini API unavailable'
      };
    }
  }

  private getMockData(endpoint: string): any {
    switch (endpoint) {
      case 'daily-horoscope':
        return this.getMockDailyHoroscope();
      case 'birth-chart':
        return this.getMockBirthChart();
      case 'compatibility':
        return this.getMockCompatibility();
      case 'panchang':
        return this.getMockPanchang();
      default:
        return null;
    }
  }

  private getMockDailyHoroscope(): DailyHoroscope {
    const signs = ['aries', 'taurus', 'gemini', 'cancer', 'leo', 'virgo', 'libra', 'scorpio', 'sagittarius', 'capricorn', 'aquarius', 'pisces'];
    const randomSign = signs[Math.floor(Math.random() * signs.length)];

    return {
      sign: randomSign,
      date: new Date().toISOString().split('T')[0],
      overall: Math.floor(Math.random() * 5) + 1,
      love: Math.floor(Math.random() * 5) + 1,
      career: Math.floor(Math.random() * 5) + 1,
      health: Math.floor(Math.random() * 5) + 1,
      finances: Math.floor(Math.random() * 5) + 1,
      mood: ['Positive', 'Energetic', 'Calm', 'Focused', 'Creative'][Math.floor(Math.random() * 5)],
      advice: "Today brings opportunities for growth and self-reflection. Trust your intuition and embrace positive changes coming your way.",
      luckyNumber: Math.floor(Math.random() * 31) + 1,
      luckyColor: ['Red', 'Blue', 'Green', 'Purple', 'Gold', 'Silver'][Math.floor(Math.random() * 6)]
    };
  }

  private getMockBirthChart(): BirthChart {
    const signs = ['aries', 'taurus', 'gemini', 'cancer', 'leo', 'virgo', 'libra', 'scorpio', 'sagittarius', 'capricorn', 'aquarius', 'pisces'];

    return {
      id: 'mock-chart-' + Date.now(),
      birthData: {
        name: 'John Doe',
        date: '1990-01-01',
        time: '12:00',
        location: 'New York, USA'
      },
      sunSign: signs[Math.floor(Math.random() * signs.length)],
      moonSign: signs[Math.floor(Math.random() * signs.length)],
      risingSign: signs[Math.floor(Math.random() * signs.length)],
      planets: [
        { name: 'Sun', sign: signs[Math.floor(Math.random() * signs.length)], degree: Math.floor(Math.random() * 30), element: 'fire' },
        { name: 'Moon', sign: signs[Math.floor(Math.random() * signs.length)], degree: Math.floor(Math.random() * 30), element: 'water' },
        { name: 'Mercury', sign: signs[Math.floor(Math.random() * signs.length)], degree: Math.floor(Math.random() * 30), element: 'air' },
        { name: 'Venus', sign: signs[Math.floor(Math.random() * signs.length)], degree: Math.floor(Math.random() * 30), element: 'earth' },
        { name: 'Mars', sign: signs[Math.floor(Math.random() * signs.length)], degree: Math.floor(Math.random() * 30), element: 'fire' }
      ],
      houses: Array.from({ length: 12 }, (_, i) => ({
        number: i + 1,
        sign: signs[Math.floor(Math.random() * signs.length)],
        cusp: Math.floor(Math.random() * 30)
      })),
      aspects: [
        {
          planet1: 'Sun',
          planet2: 'Moon',
          type: 'trine',
          angle: 120,
          orb: 3
        }
      ]
    };
  }

  private getMockCompatibility(): CompatibilityData {
    return {
      personA: {
        name: 'Person A',
        date: '1990-01-01',
        time: '12:00',
        location: 'New York, USA'
      },
      personB: {
        name: 'Person B',
        date: '1992-06-15',
        time: '15:30',
        location: 'Los Angeles, USA'
      },
      overall: Math.floor(Math.random() * 40) + 60,
      love: Math.floor(Math.random() * 40) + 60,
      communication: Math.floor(Math.random() * 40) + 60,
      trust: Math.floor(Math.random() * 40) + 60,
      values: Math.floor(Math.random() * 40) + 60,
      description: "This relationship has strong potential for growth and mutual understanding. Communication is key to maintaining harmony.",
      advice: [
        "Practice active listening",
        "Respect each other's independence",
        "Find common interests to explore together",
        "Be patient with differences"
      ],
      challenges: [
        "Different communication styles",
        "Varying emotional needs",
        "Conflict resolution approaches"
      ]
    };
  }

  private getMockPanchang(): Panchang {
    return {
      date: new Date().toISOString().split('T')[0],
      sunrise: '06:30',
      sunset: '18:45',
      moonPhase: 'Waxing Gibbous',
      nakshatra: 'Rohini',
      tithi: 'Panchami',
      yoga: 'Siddha',
      karana: 'Balava',
      auspiciousPeriods: [
        { start: '06:00', end: '08:00', type: 'Abhijit Muhurat' },
        { start: '12:00', end: '14:00', type: 'Rahu Kalam' },
        { start: '17:00', end: '18:00', type: 'Gulikai Kalam' }
      ]
    };
  }

  async getDailyHoroscope(sign: string, date?: string): Promise<ApiResponse<DailyHoroscope>> {
    const targetDate = date || new Date().toISOString().split('T')[0];

    return this.handleGeminiCall<DailyHoroscope>(
      () => geminiApi.generateDailyHoroscope(sign, targetDate),
      'daily-horoscope'
    );
  }

  async getBirthChart(birthData: BirthData): Promise<ApiResponse<BirthChart>> {
    return this.handleGeminiCall<BirthChart>(
      () => geminiApi.generateBirthChart(birthData),
      'birth-chart'
    );
  }

  async getCompatibility(personA: BirthData, personB: BirthData): Promise<ApiResponse<CompatibilityData>> {
    return this.handleGeminiCall<CompatibilityData>(
      () => geminiApi.generateCompatibility(personA, personB),
      'compatibility'
    );
  }

  async getPanchang(date: string, location: string): Promise<ApiResponse<Panchang>> {
    return this.handleGeminiCall<Panchang>(
      () => geminiApi.generatePanchang(date, location),
      'panchang'
    );
  }

}

export const astrologyApi = new AstrologyAPI();
export default astrologyApi;